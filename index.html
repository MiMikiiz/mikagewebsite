<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mikage Aya | NEC所属のページ</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <canvas id="matrix-canvas" aria-hidden="true"></canvas>
  <main>
    <nav class="site-nav" aria-label="Page sections">
      <a href="#arcade">Arcade</a>
      <a href="#particles">Particles</a>
      <a href="#pyramid">Pyramid</a>
      <a href="#profile">Profile</a>
    </nav>
    <section class="game-panel">
      <span id="arcade"></span>
      <h2>Arcade Mode</h2>
      <div class="game-wrapper">
        <canvas id="flappy-canvas" width="520" height="360" role="img" aria-label="Flappy Bird style game"></canvas>
        <div class="game-overlay">
          <div class="scoreboard">
            Score: <span id="score">0</span> |
            Best: <span id="best">0</span>
          </div>
          <p id="game-message" class="game-message">Press Space to jump</p>
        </div>
      </div>
    </section>
    <section class="p5-panel">
      <span id="particles"></span>
      <h2>Particle Field</h2>
      <div class="p5-wrapper">
        <div id="p5-container"></div>
        <p class="p5-caption">p5.jsで描く、近づくと線でつながるパーティクル</p>
      </div>
    </section>
    <section class="three-panel">
      <span id="pyramid"></span>
      <h2>Pyramid Stack</h2>
      <div class="three-wrapper">
        <div id="three-container"></div>
        <p class="three-caption">three.jsで上から積み重なるカラフルなブロック</p>
      </div>
    </section>
    <section id="profile">
      <h2>Personal Profile</h2>
      <h1>Mikage Aya</h1>
      <p class="lead">NEC　ここ変更</p>

      <div class="section">
        <p class="label">所属</p>
        <p>NEC（日本電気株式会社）での経験を通じ、技術とデザインの交差点にある課題に取り組んでいます。</p>
      </div>

      <div class="section">
        <p class="label">クリエイティブな側面</p>
        <p>ベースとなるスタイルはフォーマルながら、柔らかくおしゃれな印象を心掛けています。服の選び方ひとつにも品格が宿ると考え、日常の中から新しい表情を見つけ出すことが好きです。</p>
      </div>

      <div class="section">
        <p class="label">趣味・関心</p>
        <ul class="tag-list">
          <li class="tag">服</li>
          <li class="tag">ゲーム</li>
          <li class="tag">絵画</li>
        </ul>
        <p>それぞれの趣味から得られる感覚を、仕事や生活の中で折り合わせ、バランスの取れた視点で新しい表現を試しています。</p>
      </div>

      <div class="section">
        <p class="label">更新</p>
        <p>このページは、シンプルながらも品のある自己紹介として定期的に見直しています。次の更新の際には、最新の取り組みや気になる展望も加えていく予定です。</p>
      </div>
    </section>
  </main>
  <script>
    (function () {
      const canvas = document.getElementById("matrix-canvas");
      if (!canvas) return;
      const ctx = canvas.getContext("2d");
      const letters = "0123456789";

      let columns = [];

      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const columnCount = Math.floor(canvas.width / 18);
        columns = new Array(columnCount).fill(0);
      }

      function draw() {
        ctx.fillStyle = "rgba(0, 8, 8, 0.16)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#75ff99";
        ctx.font = "18px Monaco, 'Courier New', monospace";

        columns.forEach((y, index) => {
          const x = index * 18;
          const text = letters.charAt(Math.floor(Math.random() * letters.length));
          ctx.fillText(text, x, y);

          if (y > canvas.height && Math.random() > 0.975) {
            columns[index] = 0;
          } else {
            columns[index] = y + 20;
          }
        });

        requestAnimationFrame(draw);
      }

      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();
      draw();
    })();
  </script>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.5.0/lib/p5.min.js"></script>
  <script>
    (function () {
      const canvas = document.getElementById("flappy-canvas");
      const scoreEl = document.getElementById("score");
      const bestEl = document.getElementById("best");
      const messageEl = document.getElementById("game-message");
      if (!canvas || !scoreEl || !bestEl || !messageEl) return;

      const ctx = canvas.getContext("2d");
      const width = canvas.width;
      const height = canvas.height;
      const gravity = 0.34;
      const jumpStrength = -6.2;
      const pipeWidth = 56;
      const pipeGap = 140;
      const pipeSpeed = 2.6;
      const bird = {
        x: 88,
        y: height / 2,
        radius: 14,
        velocity: 0,
      };
      let pipes = [];
      let frame = 0;
      let score = 0;
      let best = 0;
      let isGameOver = false;

      function resetGame() {
        bird.y = height / 2;
        bird.velocity = 0;
        pipes = [];
        frame = 0;
        score = 0;
        isGameOver = false;
        scoreEl.textContent = "0";
        messageEl.textContent = "Press Space to jump";
      }

      function addPipe() {
        const minTop = 40;
        const maxTop = height - pipeGap - 60;
        const topHeight = minTop + Math.random() * (Math.max(minTop, maxTop) - minTop);
        pipes.push({
          x: width,
          top: topHeight,
          touched: false,
        });
      }

      function triggerGameOver() {
        isGameOver = true;
        best = Math.max(best, score);
        bestEl.textContent = best.toString();
        messageEl.textContent = "Game over · Space to restart";
      }

      function draw() {
        ctx.fillStyle = "#010409";
        ctx.fillRect(0, 0, width, height);

        ctx.fillStyle = "#79ff9d";
        ctx.beginPath();
        ctx.arc(bird.x, bird.y, bird.radius, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = "#0c3f18";
        pipes.forEach((pipe) => {
          ctx.fillRect(pipe.x, 0, pipeWidth, pipe.top);
          ctx.fillRect(pipe.x, pipe.top + pipeGap, pipeWidth, height - pipe.top - pipeGap);
        });

        if (!isGameOver) {
          bird.velocity += gravity;
          bird.y += bird.velocity;
          if (bird.y + bird.radius >= height) {
            bird.y = height - bird.radius;
            triggerGameOver();
          } else if (bird.y - bird.radius <= 0) {
            bird.y = bird.radius;
            bird.velocity = 0;
          }

          frame++;
          if (frame % 100 === 0) {
            addPipe();
          }

          pipes.forEach((pipe) => {
            pipe.x -= pipeSpeed;
            if (!pipe.touched && pipe.x + pipeWidth < bird.x) {
              score++;
              pipe.touched = true;
              scoreEl.textContent = score.toString();
            }
          });

          pipes = pipes.filter((pipe) => pipe.x + pipeWidth > 0);

          pipes.forEach((pipe) => {
            if (
              bird.x + bird.radius > pipe.x &&
              bird.x - bird.radius < pipe.x + pipeWidth &&
              (bird.y - bird.radius < pipe.top || bird.y + bird.radius > pipe.top + pipeGap)
            ) {
              triggerGameOver();
            }
          });
        }

        requestAnimationFrame(draw);
      }

      function flap() {
        bird.velocity = jumpStrength;
        if (isGameOver) {
          resetGame();
        }
      }

      window.addEventListener("keydown", (event) => {
        if (event.code === "Space") {
          event.preventDefault();
          flap();
        }
      });

      resetGame();
      draw();
    })();
  </script>
  <script>
    (function () {
      if (typeof p5 === "undefined") return;

      const sketch = (p) => {
        const particleCount = 120;
        const proximity = 110;
        const particles = [];

        class Particle {
          constructor() {
            this.pos = p.createVector(p.random(p.width), p.random(p.height));
            this.vel = p5.Vector.random2D().mult(p.random(0.4, 1.2));
            this.size = p.random(2, 4);
          }

          update() {
            this.pos.add(this.vel);
            if (this.pos.x < 0 || this.pos.x > p.width) {
              this.vel.x *= -1;
            }
            if (this.pos.y < 0 || this.pos.y > p.height) {
              this.vel.y *= -1;
            }
          }

          draw() {
            p.noStroke();
            p.fill(86, 255, 146, 220);
            p.circle(this.pos.x, this.pos.y, this.size);
          }
        }

        p.setup = () => {
          const canvasEl = p.createCanvas(520, 320);
          canvasEl.parent("p5-container");
          p.pixelDensity(1);
          for (let i = 0; i < particleCount; i++) {
            particles.push(new Particle());
          }
        };

        p.draw = () => {
          p.background(1, 4, 9, 120);
          particles.forEach((particle, index) => {
            particle.update();
            particle.draw();

            for (let j = index + 1; j < particles.length; j++) {
              const other = particles[j];
              const dist = p.dist(particle.pos.x, particle.pos.y, other.pos.x, other.pos.y);
              if (dist < proximity) {
                const alpha = p.map(dist, 0, proximity, 180, 6);
                p.stroke(89, 255, 150, alpha);
                p.strokeWeight(1);
                p.line(particle.pos.x, particle.pos.y, other.pos.x, other.pos.y);
              }
            }
          });
        };
      };

    new p5(sketch);
  })();
</script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
  <script>
    (function () {
      if (typeof THREE === "undefined") return;
      const container = document.getElementById("three-container");
      if (!container) return;

      const width = 520;
      const height = 340;
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x010409);
      const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 200);
      camera.position.set(0, 28, 48);
      camera.lookAt(0, 10, 0);

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(width, height);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      container.appendChild(renderer.domElement);

      const ambient = new THREE.AmbientLight(0xffffff, 0.55);
      const directional = new THREE.DirectionalLight(0xa4ffce, 0.65);
      directional.position.set(8, 20, 14);
      scene.add(ambient, directional);

      const blockSize = 3.6;
      const gap = 0.4;
      const rows = 6;
      const baseCount = rows + 2;
      const positions = [];
      for (let row = 0; row < rows; row++) {
        const count = baseCount - row;
        const y = row * (blockSize + gap) - blockSize / 2;
        const rowOffset = ((count - 1) * (blockSize + gap)) / 2;
        for (let index = 0; index < count; index++) {
          const x = index * (blockSize + gap) - rowOffset;
          const z = row * (blockSize / 2) - rows;
          positions.push({ x, y, z });
        }
      }

      const active = [];
      const colors = [
        0xff5c8d,
        0x74ffd5,
        0xfad02c,
        0x8ef9ff,
        0xff9f59,
        0x7b5bff,
      ];

      const queue = positions.slice();

      function spawnBlock() {
        if (!queue.length) return;
        const target = queue.shift();
        const hue = colors[Math.floor(Math.random() * colors.length)];
        const geometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
        const material = new THREE.MeshStandardMaterial({ color: hue, roughness: 0.35, metalness: 0.2 });
        const block = new THREE.Mesh(geometry, material);
        block.position.set(target.x + (Math.random() - 0.5), 32, target.z + (Math.random() - 0.5));
        block.userData = {
          target,
          velocity: 0.7 + Math.random() * 0.8,
          state: "falling",
        };
        active.push(block);
        scene.add(block);
      }

      const spawnInterval = setInterval(() => {
        spawnBlock();
        if (!queue.length) {
          clearInterval(spawnInterval);
        }
      }, 620);

      const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(80, 80),
        new THREE.MeshStandardMaterial({ color: 0x031219 })
      );
      floor.rotation.x = -Math.PI / 2;
      floor.position.y = -8;
      scene.add(floor);

      function animate() {
        active.forEach((block) => {
          const target = block.userData.target;
          if (block.userData.state === "falling") {
            block.userData.velocity += 0.09;
            block.position.y -= block.userData.velocity;
            block.position.x += (target.x - block.position.x) * 0.08;
            block.position.z += (target.z - block.position.z) * 0.08;
            if (block.position.y <= target.y) {
              block.position.y = target.y;
              block.userData.state = "settled";
              block.userData.velocity = 0;
            }
          } else {
            block.rotation.y += 0.006;
          }
        });

        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }

      function handleResize() {
        const parentWidth = container.clientWidth;
        const ratio = parentWidth / width;
        renderer.setSize(parentWidth, height * ratio);
        camera.aspect = parentWidth / (height * ratio);
        camera.updateProjectionMatrix();
      }

      window.addEventListener("resize", handleResize);
      handleResize();
      animate();
    })();
  </script>
</body>
</html>
